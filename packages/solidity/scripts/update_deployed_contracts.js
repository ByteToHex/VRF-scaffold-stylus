#!/usr/bin/env node

/**
 * Script to update deployedContracts.ts with Solidity contract deployment information
 * Usage: node update_deployed_contracts.js <chainId> <contractName> <address> <txHash> <abiPath>
 */

const fs = require('fs');
const path = require('path');

// Get the generated contract comment (same as Stylus)
const generatedContractComment = `/**
 * This file is autogenerated by scaffold-stylus.
 * You should not edit it manually or your changes might be overwritten.
 */
import { GenericContractsDeclaration } from "../utils/scaffold-eth/contract";`;

async function updateDeployedContracts(chainId, contractName, address, txHash, abiPath) {
  const TARGET_DIR = path.resolve(__dirname, "../../nextjs/contracts/");
  const TARGET_FILE = path.join(TARGET_DIR, "deployedContracts.ts");
  
  // Read ABI file
  if (!fs.existsSync(abiPath)) {
    console.error(`‚ùå ABI file not found: ${abiPath}`);
    process.exit(1);
  }
  
  const abiContent = fs.readFileSync(abiPath, "utf8");
  let abiJson;
  try {
    abiJson = JSON.parse(abiContent);
  } catch (e) {
    console.error(`‚ùå Failed to parse ABI file: ${e.message}`);
    process.exit(1);
  }

  const newContractEntry = {
    address: address,
    txHash: txHash,
    abi: abiJson,
  };

  // Read existing deployedContracts.ts if it exists
  let deployedContractsObj = {};
  const fileHeader = generatedContractComment + "\n\n";

  if (fs.existsSync(TARGET_FILE)) {
    const fileContent = fs.readFileSync(TARGET_FILE, "utf8");
    // Extract the deployedContracts object using regex
    const match = fileContent.match(/const deployedContracts = ([\s\S]*?) as const;/);
    if (match) {
      try {
        // Use eval to parse the JavaScript object (same approach as Stylus script)
        // eslint-disable-next-line no-eval
        deployedContractsObj = eval("(" + match[1] + ")");
      } catch (e) {
        console.error(`‚ùå Failed to parse existing deployedContracts.ts: ${e.message}`);
        process.exit(1);
      }
    }
  }

  // Update the object structure
  if (!deployedContractsObj[chainId]) {
    deployedContractsObj[chainId] = {};
  }
  deployedContractsObj[chainId][contractName] = newContractEntry;

  // Format the output
  const contractsString = JSON.stringify(deployedContractsObj, null, 2);
  const output = `${fileHeader}const deployedContracts = ${contractsString} as const;\n\nexport default deployedContracts satisfies GenericContractsDeclaration;\n`;

  // Ensure target directory exists
  if (!fs.existsSync(TARGET_DIR)) {
    fs.mkdirSync(TARGET_DIR, { recursive: true });
  }

  // Format with prettier if available, otherwise write directly
  try {
    // Try to use prettier from node_modules (from stylus package or root)
    let prettier;
    try {
      const prettierPath = require.resolve('prettier', { paths: [__dirname, path.resolve(__dirname, '../../'), path.resolve(__dirname, '../../../')] });
      prettier = require(prettierPath);
    } catch (resolveError) {
      // Try direct require as fallback
      prettier = require('prettier');
    }
    const formatted = await prettier.format(output, { parser: "typescript" });
    fs.writeFileSync(TARGET_FILE, formatted);
  } catch (e) {
    // If prettier is not available, write without formatting
    console.warn(`‚ö†Ô∏è  Prettier not available (${e.message}), writing without formatting`);
    fs.writeFileSync(TARGET_FILE, output);
  }

  console.log(`üìù Updated TypeScript contract definition file: ${TARGET_FILE}`);
  console.log(`   Chain ID: ${chainId}`);
  console.log(`   Contract: ${contractName}`);
  console.log(`   Address: ${address}`);
}

// Parse command line arguments
const args = process.argv.slice(2);
if (args.length !== 5) {
  console.error("Usage: node update_deployed_contracts.js <chainId> <contractName> <address> <txHash> <abiPath>");
  process.exit(1);
}

const [chainId, contractName, address, txHash, abiPath] = args;

// Resolve ABI path relative to script directory
const resolvedAbiPath = path.isAbsolute(abiPath) ? abiPath : path.resolve(__dirname, "..", abiPath);

updateDeployedContracts(chainId, contractName, address, txHash, resolvedAbiPath)
  .then(() => {
    console.log("‚úÖ Successfully updated deployedContracts.ts");
  })
  .catch((error) => {
    console.error("‚ùå Failed to update deployedContracts.ts:", error.message);
    process.exit(1);
  });

