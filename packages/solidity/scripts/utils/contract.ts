import * as path from "path";
import * as fs from "fs";
import { ethers } from "ethers";
import prettier from "prettier";
import { DeploymentData, ExportConfig } from "./type";
import { getContractDataFromDeployments } from "./deployment";
import { Address } from "viem";

export const generatedContractComment = `
/**
 * This file is autogenerated by scaffold-stylus.
 * You should not edit it manually or your changes might be overwritten.
 */
import { GenericContractsDeclaration } from "../utils/scaffold-eth/contract";
`;

/**
 * Reads the contract name from the Solidity file name
 * @param contractFolder Contract folder name (e.g., "ERC20Example")
 * @returns Contract name
 */
export function getContractNameFromSolidityFile(contractFolder: string): string {
  // For Solidity, contract name is typically the folder name or file name
  // We'll use the folder name as the contract name
  return contractFolder;
}

/**
 * Checks if contract has a constructor by reading the Solidity file
 * @param contractFolder Contract folder or contract name
 * @returns true if constructor exists
 */
export function isContractHasConstructor(contractFolder: string): boolean {
  // Try to find the Solidity file
  const contractName = getContractNameFromSolidityFile(contractFolder);
  const contractPath = path.resolve(__dirname, "../../src", `${contractName}.sol`);
  
  if (!fs.existsSync(contractPath)) {
    // If not found, try with different casing
    const files = fs.readdirSync(path.resolve(__dirname, "../../src"));
    const matchingFile = files.find(f => f.toLowerCase() === `${contractName.toLowerCase()}.sol`);
    if (!matchingFile) {
      return false; // Default to true for Solidity contracts
    }
    const actualPath = path.resolve(__dirname, "../../src", matchingFile);
    const contractContent = fs.readFileSync(actualPath, "utf8");
    return contractContent.includes("constructor(");
  }
  
  const contractContent = fs.readFileSync(contractPath, "utf8");
  return contractContent.includes("constructor(");
}

export function getExportConfig(
  contractFolder?: string,
  contractName?: string,
  chainId?: string,
): ExportConfig {
  if (!contractFolder) {
    throw new Error("Contract folder is required");
  }

  contractName = contractName || getContractNameFromSolidityFile(contractFolder);
  // Use shared deployments directory from stylus package
  const deploymentDir = path.resolve(__dirname, "../../../stylus/deployments");

  const deploymentData = getContractDataFromDeployments(
    deploymentDir,
    contractName,
    chainId,
  );
  if (!deploymentData) {
    throw new Error(
      `âŒ Contract address for '${contractName}' not found in any chain-specific deployment files in ${deploymentDir}. Please deploy the contract first.`,
    );
  }

  return {
    contractFolder,
    contractName,
    deploymentDir,
    contractAddress: deploymentData.address as Address,
    txHash: deploymentData.txHash,
    chainId: deploymentData.chainId,
  };
}

export function isContractFolder(contractFolder: string): boolean {
  const contractName = getContractNameFromSolidityFile(contractFolder);
  const contractPath = path.resolve(__dirname, "../../src", `${contractName}.sol`);
  
  // Check if Solidity file exists
  if (fs.existsSync(contractPath)) {
    return true;
  }
  
  // Try case-insensitive search
  const srcDir = path.resolve(__dirname, "../../src");
  if (fs.existsSync(srcDir)) {
    const files = fs.readdirSync(srcDir);
    const matchingFile = files.find(f => f.toLowerCase() === `${contractName.toLowerCase()}.sol`);
    return !!matchingFile;
  }
  
  return false;
}

export function generateContractAddress(): string {
  // Generate a random private key and derive the address
  const wallet = ethers.Wallet.createRandom();
  return wallet.address;
}

export function extractDeploymentInfo(output: string): DeploymentData | null {
  let result: DeploymentData | null = null;
  const lines = output.split("\n");
  
  for (const line of lines) {
    // Foundry output format: "Deployed to: 0x..."
    if (line.includes("Deployed to:")) {
      const hexMatch = line.match(/(0x[a-fA-F0-9]{40})/);
      if (hexMatch && hexMatch[1]) {
        result = { address: hexMatch[1] as Address, txHash: "" };
      }
    }
    // Foundry output format: "Transaction hash: 0x..."
    if (line.includes("Transaction hash:") || line.includes("txHash:")) {
      const txHashMatch = line.match(/(0x[a-fA-F0-9]{64})/);
      if (txHashMatch && txHashMatch[1]) {
        result = {
          address: result?.address as Address,
          txHash: txHashMatch[1],
        };
      }
    }
  }
  
  return result;
}

export function extractGasPriceFromOutput(output: string): string | null {
  const lines = output.split("\n");
  for (const line of lines) {
    if (line.includes("gas price:") || line.includes("Gas price:")) {
      // Remove ANSI color codes first
      // eslint-disable-next-line no-control-regex
      const cleanLine = line.replace(/\x1b\[[0-9;]*m/g, "");

      const match = cleanLine.match(/gas price:?\s*(\d+)/i);
      if (match && match[1]) {
        return match[1];
      }
    }
  }
  return null;
}

export async function generateTsAbi(
  abiFilePath: string,
  contractName: string,
  contractAddress: string,
  txHash: string,
  chainId: string,
) {
  const TARGET_DIR = "../../nextjs/contracts/";
  const TARGET_FILE = `${TARGET_DIR}deployedContracts.ts`;
  const abiTxt = fs.readFileSync(abiFilePath, "utf8");

  // Parse ABI JSON
  let abiJson;
  try {
    abiJson = JSON.parse(abiTxt);
  } catch (e) {
    // If it's not valid JSON, try to extract JSON from the file
    const jsonMatch = abiTxt.match(/\[[\s\S]*\]/);
    if (jsonMatch) {
      abiJson = JSON.parse(jsonMatch[0]);
    } else {
      throw new Error(`Failed to parse ABI from ${abiFilePath}`);
    }
  }

  const newContractEntry = {
    address: contractAddress,
    txHash: txHash,
    abi: abiJson,
  };

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  let deployedContractsObj: any = {};
  const fileHeader = generatedContractComment + "\n\n";

  if (fs.existsSync(TARGET_FILE)) {
    const fileContent = fs.readFileSync(TARGET_FILE, "utf8");
    // Extract the deployedContracts object using regex
    const match = fileContent.match(
      /const deployedContracts = ([\s\S]*?) as const;/,
    );
    if (match) {
      // eslint-disable-next-line no-eval
      deployedContractsObj = eval("(" + match[1] + ")");
    }
  }

  if (!deployedContractsObj[chainId]) {
    deployedContractsObj[chainId] = {};
  }
  deployedContractsObj[chainId][contractName] = newContractEntry;

  const contractsString = JSON.stringify(deployedContractsObj, null, 2);

  const output = `${fileHeader}const deployedContracts = ${contractsString} as const;\n\nexport default deployedContracts satisfies GenericContractsDeclaration;\n`;

  if (!fs.existsSync(TARGET_DIR)) {
    fs.mkdirSync(TARGET_DIR, { recursive: true });
  }

  fs.writeFileSync(
    TARGET_FILE,
    await prettier.format(output, { parser: "typescript" }),
  );

  console.log(
    `ðŸ“ Updated TypeScript contract definition file on ${TARGET_FILE}`,
  );
}

export function handleSolcError(
  error: Error,
  context: string = "ABI export",
): void {
  console.error(`\nâŒ ${context} failed!`);
  console.error("\nðŸ” Error details:", error.message);

  // Check if the error is related to forge not being found
  if (
    error.message.includes("forge") ||
    error.message.includes("foundry") ||
    error.message.includes("command not found")
  ) {
    console.error(
      "\nðŸ’¡ It appears that Foundry is not installed on your system.",
    );
    console.error("\nðŸ“š To install Foundry, please visit:");
    console.error(
      "   https://book.getfoundry.sh/getting-started/installation",
    );
    console.error(
      "\nðŸš€ After installing Foundry, you can run this command again:",
    );
    console.error("   yarn solidity:export-abi");
    console.error("\nðŸ“‹ Quick installation:");
    console.error("   curl -L https://foundry.paradigm.xyz | bash");
    console.error("   foundryup");
  } else {
    console.error("\nðŸ’¡ Please check the error details above and try again.");
  }
}

/**
 * Dynamically load deployed contracts from the TypeScript file
 * This is useful when the file has been updated during runtime
 * @returns The deployed contracts object
 */
export function loadDeployedContracts() {
  const deployedContractsPath = "../../nextjs/contracts/deployedContracts.ts";

  if (!fs.existsSync(deployedContractsPath)) {
    throw new Error("deployedContracts.ts file not found");
  }

  const fileContent = fs.readFileSync(deployedContractsPath, "utf8");
  const match = fileContent.match(
    /const deployedContracts = ([\s\S]*?) as const;/,
  );

  if (!match) {
    throw new Error("Could not parse deployedContracts.ts file");
  }

  // eslint-disable-next-line no-eval
  return eval("(" + match[1] + ")");
}

/**
 * Get contract data from deployed contracts
 * @param chainId - The chain ID
 * @param contractName - The contract name
 * @returns The contract data with address, txHash, and abi
 */
export function getContractData(chainId: string, contractName: string) {
  const deployedContracts = loadDeployedContracts();

  if (
    !deployedContracts ||
    !deployedContracts[chainId] ||
    !deployedContracts[chainId][contractName]
  ) {
    throw new Error(
      `Contract ${contractName} not found in deployedContracts for chain ${chainId}`,
    );
  }

  const contractData = deployedContracts[chainId][contractName];
  if (!contractData.abi) {
    throw new Error(
      `ABI not found for contract ${contractName} on chain ${chainId}`,
    );
  }

  return contractData;
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function contractHasInitializeFunction(contractData: any): boolean {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return contractData.abi.some((abi: any) => abi.name === "initialize");
}

