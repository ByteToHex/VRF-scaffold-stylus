import * as path from "path";
import * as fs from "fs";
import { ethers } from "ethers";
import prettier from "prettier";
import { DeploymentData, ExportConfig } from "./type";
import { getContractDataFromDeployments } from "./deployment";
import { Address } from "viem";

export const generatedContractComment = `
/**
 * This file is autogenerated by scaffold-stylus.
 * You should not edit it manually or your changes might be overwritten.
 */
import { GenericContractsDeclaration } from "../utils/scaffold-eth/contract";
`;

/**
 * Reads the contract name from the Solidity file name
 * @param contractFolder Contract folder name (e.g., "ERC20Example")
 * @returns Contract name
 */
export function getContractNameFromSolidityFile(contractFolder: string): string {
  // For Solidity, contract name is typically the folder name or file name
  // We'll use the folder name as the contract name
  return contractFolder;
}

/**
 * Checks if contract has a constructor by reading the Solidity file
 * @param contractFolder Contract folder or contract name
 * @returns true if constructor exists
 */
export function isContractHasConstructor(contractFolder: string): boolean {
  // Try to find the Solidity file
  const contractName = getContractNameFromSolidityFile(contractFolder);
  const contractPath = path.resolve(__dirname, "../../src", `${contractName}.sol`);
  
  if (!fs.existsSync(contractPath)) {
    // If not found, try with different casing
    const files = fs.readdirSync(path.resolve(__dirname, "../../src"));
    const matchingFile = files.find(f => f.toLowerCase() === `${contractName.toLowerCase()}.sol`);
    if (!matchingFile) {
      return false; // Default to true for Solidity contracts
    }
    const actualPath = path.resolve(__dirname, "../../src", matchingFile);
    const contractContent = fs.readFileSync(actualPath, "utf8");
    return contractContent.includes("constructor(");
  }
  
  const contractContent = fs.readFileSync(contractPath, "utf8");
  return contractContent.includes("constructor(");
}

export function getExportConfig(
  contractFolder?: string,
  contractName?: string,
  chainId?: string,
): ExportConfig {
  if (!contractFolder) {
    throw new Error("Contract folder is required");
  }

  contractName = contractName || getContractNameFromSolidityFile(contractFolder);
  // Use shared deployments directory from stylus package
  const deploymentDir = path.resolve(__dirname, "../../../stylus/deployments");

  const deploymentData = getContractDataFromDeployments(
    deploymentDir,
    contractName,
    chainId,
  );
  if (!deploymentData) {
    throw new Error(
      `âŒ Contract address for '${contractName}' not found in any chain-specific deployment files in ${deploymentDir}. Please deploy the contract first.`,
    );
  }

  return {
    contractFolder,
    contractName,
    deploymentDir,
    contractAddress: deploymentData.address as Address,
    txHash: deploymentData.txHash,
    chainId: deploymentData.chainId,
  };
}

export function isContractFolder(contractFolder: string): boolean {
  const contractName = getContractNameFromSolidityFile(contractFolder);
  const contractPath = path.resolve(__dirname, "../../src", `${contractName}.sol`);
  
  // Check if Solidity file exists
  if (fs.existsSync(contractPath)) {
    return true;
  }
  
  // Try case-insensitive search
  const srcDir = path.resolve(__dirname, "../../src");
  if (fs.existsSync(srcDir)) {
    const files = fs.readdirSync(srcDir);
    const matchingFile = files.find(f => f.toLowerCase() === `${contractName.toLowerCase()}.sol`);
    return !!matchingFile;
  }
  
  return false;
}

export function generateContractAddress(): string {
  // Generate a random private key and derive the address
  const wallet = ethers.Wallet.createRandom();
  return wallet.address;
}

export function extractDeploymentInfo(output: string): DeploymentData | null {
  // First, try to parse as JSON (if --json flag was used)
  try {
    // Try to parse the entire output as JSON first
    const trimmedOutput = output.trim();
    const jsonOutput = JSON.parse(trimmedOutput);
    
    // Foundry JSON format has:
    // - deployedTo: contract address
    // - transactionHash or hash: transaction hash
    const address = jsonOutput.deployedTo || jsonOutput.result?.deployedTo;
    const txHash = jsonOutput.transactionHash || jsonOutput.hash || jsonOutput.result?.transactionHash || jsonOutput.result?.hash || "";
    
    if (address) {
      return {
        address: address as Address,
        txHash: txHash,
      };
    }
  } catch (e) {
    // If full output isn't JSON, try to find JSON object in the output
    // Look for lines that might contain JSON with "deployedTo"
    const lines = output.split("\n");
    for (const line of lines) {
      const trimmedLine = line.trim();
      if (trimmedLine.startsWith("{") && trimmedLine.includes("deployedTo")) {
        try {
          const jsonOutput = JSON.parse(trimmedLine);
          const address = jsonOutput.deployedTo || jsonOutput.result?.deployedTo;
          const txHash = jsonOutput.transactionHash || jsonOutput.hash || jsonOutput.result?.transactionHash || jsonOutput.result?.hash || "";
          
          if (address) {
            return {
              address: address as Address,
              txHash: txHash,
            };
          }
        } catch (e2) {
          // This line isn't valid JSON, continue
        }
      }
    }
  }

  let result: DeploymentData | null = null;
  const lines = output.split("\n");
  let deployerAddress: string | null = null;
  
  // Try to extract from standard Foundry text format (fallback)
  for (const line of lines) {
    // Foundry output format: "Deployed to: 0x..."
    if (line.includes("Deployed to:") || line.includes("deployed to:")) {
      const hexMatch = line.match(/(0x[a-fA-F0-9]{40})/);
      if (hexMatch && hexMatch[1]) {
        result = { address: hexMatch[1] as Address, txHash: result?.txHash || "" };
        break; // Found the address, we can stop looking
      }
    }
    // Foundry output format: "Transaction hash: 0x..." or "txHash: 0x..."
    if (line.includes("Transaction hash:") || line.includes("txHash:") || line.includes("transactionHash:")) {
      const txHashMatch = line.match(/(0x[a-fA-F0-9]{64})/);
      if (txHashMatch && txHashMatch[1]) {
        if (result) {
          result.txHash = txHashMatch[1];
        } else {
          result = { address: "" as Address, txHash: txHashMatch[1] };
        }
      }
    }
    // Extract deployer address from "from" field for later use
    if (line.includes('"from"') || line.includes("from:")) {
      const fromMatch = line.match(/(0x[a-fA-F0-9]{40})/);
      if (fromMatch && fromMatch[1]) {
        deployerAddress = fromMatch[1];
      }
    }
  }
  
  // If we found the address in standard format, return it
  if (result?.address) {
    return result;
  }
  
  // Try to extract from JSON format (if forge outputs JSON)
  try {
    // Look for JSON objects in the output - try to find the full transaction object
    const jsonMatch = output.match(/\{[\s\S]*?"from"[\s\S]*?\}/);
    if (jsonMatch) {
      const jsonStr = jsonMatch[0];
      const jsonObj = JSON.parse(jsonStr);
      
      // For contract creation, "to" is null, so we need to look elsewhere
      // Try to find transaction hash in JSON
      if (jsonObj.hash) {
        if (!result) {
          result = { address: "" as Address, txHash: jsonObj.hash };
        } else {
          result.txHash = jsonObj.hash;
        }
      }
      
      // Store deployer address if found
      if (jsonObj.from) {
        deployerAddress = jsonObj.from;
      }
    }
  } catch (e) {
    // JSON parsing failed, continue with other methods
  }
  
  // Last resort: look for addresses in the output, but be smart about it
  // Foundry typically outputs the contract address after "Contract:" line
  if (!result?.address) {
    let foundContractLine = false;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (line && line.includes("Contract:") && !foundContractLine) {
        foundContractLine = true;
        // Look for address in the next few lines after "Contract:"
        for (let j = i + 1; j < Math.min(i + 5, lines.length); j++) {
          const nextLine = lines[j];
          if (nextLine) {
            const hexMatch = nextLine.match(/(0x[a-fA-F0-9]{40})/);
            if (hexMatch && hexMatch[1]) {
              // Make sure it's not the deployer address
              if (!deployerAddress || hexMatch[1].toLowerCase() !== deployerAddress.toLowerCase()) {
                result = { address: hexMatch[1] as Address, txHash: result?.txHash || "" };
                break;
              }
            }
          }
        }
        if (result?.address) break;
      }
    }
  }
  
  // Final fallback: find all addresses and exclude the deployer
  if (!result?.address) {
    const addressMatches = output.match(/(0x[a-fA-F0-9]{40})/g);
    if (addressMatches && addressMatches.length > 0) {
      // Filter out deployer address if we know it
      const uniqueAddresses = [...new Set(addressMatches)];
      const filteredAddresses = deployerAddress
        ? uniqueAddresses.filter(addr => addr.toLowerCase() !== deployerAddress!.toLowerCase())
        : uniqueAddresses;
      
      if (filteredAddresses.length > 0) {
        // Take the last unique address (often the contract address comes after deployer)
        result = { address: filteredAddresses[filteredAddresses.length - 1] as Address, txHash: result?.txHash || "" };
      } else if (uniqueAddresses.length > 0) {
        // If all addresses are the deployer, take the last one anyway (might be wrong but better than nothing)
        result = { address: uniqueAddresses[uniqueAddresses.length - 1] as Address, txHash: result?.txHash || "" };
      }
    }
  }
  
  // If we still don't have a txHash, try to find any 64-character hex hash in the output
  if (result?.address && !result.txHash) {
    const txHashMatches = output.match(/(0x[a-fA-F0-9]{64})/g);
    if (txHashMatches && txHashMatches.length > 0) {
      result.txHash = txHashMatches[0];
    }
  }
  
  return result;
}

export function extractGasPriceFromOutput(output: string): string | null {
  const lines = output.split("\n");
  for (const line of lines) {
    if (line.includes("gas price:") || line.includes("Gas price:")) {
      // Remove ANSI color codes first
      // eslint-disable-next-line no-control-regex
      const cleanLine = line.replace(/\x1b\[[0-9;]*m/g, "");

      const match = cleanLine.match(/gas price:?\s*(\d+)/i);
      if (match && match[1]) {
        return match[1];
      }
    }
  }
  return null;
}

export async function generateTsAbi(
  abiFilePath: string,
  contractName: string,
  contractAddress: string,
  txHash: string,
  chainId: string,
) {
  const TARGET_DIR = "../../nextjs/contracts/";
  const TARGET_FILE = `${TARGET_DIR}deployedContracts.ts`;
  const abiTxt = fs.readFileSync(abiFilePath, "utf8");

  // Parse ABI JSON
  let abiJson;
  try {
    abiJson = JSON.parse(abiTxt);
  } catch (e) {
    // If it's not valid JSON, try to extract JSON from the file
    const jsonMatch = abiTxt.match(/\[[\s\S]*\]/);
    if (jsonMatch) {
      abiJson = JSON.parse(jsonMatch[0]);
    } else {
      throw new Error(`Failed to parse ABI from ${abiFilePath}`);
    }
  }

  const newContractEntry = {
    address: contractAddress,
    txHash: txHash,
    abi: abiJson,
  };

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  let deployedContractsObj: any = {};
  const fileHeader = generatedContractComment + "\n\n";

  if (fs.existsSync(TARGET_FILE)) {
    const fileContent = fs.readFileSync(TARGET_FILE, "utf8");
    // Extract the deployedContracts object using regex
    const match = fileContent.match(
      /const deployedContracts = ([\s\S]*?) as const;/,
    );
    if (match) {
      // eslint-disable-next-line no-eval
      deployedContractsObj = eval("(" + match[1] + ")");
    }
  }

  if (!deployedContractsObj[chainId]) {
    deployedContractsObj[chainId] = {};
  }
  deployedContractsObj[chainId][contractName] = newContractEntry;

  const contractsString = JSON.stringify(deployedContractsObj, null, 2);

  const output = `${fileHeader}const deployedContracts = ${contractsString} as const;\n\nexport default deployedContracts satisfies GenericContractsDeclaration;\n`;

  if (!fs.existsSync(TARGET_DIR)) {
    fs.mkdirSync(TARGET_DIR, { recursive: true });
  }

  fs.writeFileSync(
    TARGET_FILE,
    await prettier.format(output, { parser: "typescript" }),
  );

  console.log(
    `ðŸ“ Updated TypeScript contract definition file on ${TARGET_FILE}`,
  );
}

export function handleSolcError(
  error: Error,
  context: string = "ABI export",
): void {
  console.error(`\nâŒ ${context} failed!`);
  console.error("\nðŸ” Error details:", error.message);

  // Check if the error is related to forge not being found
  if (
    error.message.includes("forge") ||
    error.message.includes("foundry") ||
    error.message.includes("command not found")
  ) {
    console.error(
      "\nðŸ’¡ It appears that Foundry is not installed on your system.",
    );
    console.error("\nðŸ“š To install Foundry, please visit:");
    console.error(
      "   https://book.getfoundry.sh/getting-started/installation",
    );
    console.error(
      "\nðŸš€ After installing Foundry, you can run this command again:",
    );
    console.error("   yarn solidity:export-abi");
    console.error("\nðŸ“‹ Quick installation:");
    console.error("   curl -L https://foundry.paradigm.xyz | bash");
    console.error("   foundryup");
  } else {
    console.error("\nðŸ’¡ Please check the error details above and try again.");
  }
}

/**
 * Dynamically load deployed contracts from the TypeScript file
 * This is useful when the file has been updated during runtime
 * @returns The deployed contracts object
 */
export function loadDeployedContracts() {
  const deployedContractsPath = "../../nextjs/contracts/deployedContracts.ts";

  if (!fs.existsSync(deployedContractsPath)) {
    throw new Error("deployedContracts.ts file not found");
  }

  const fileContent = fs.readFileSync(deployedContractsPath, "utf8");
  const match = fileContent.match(
    /const deployedContracts = ([\s\S]*?) as const;/,
  );

  if (!match) {
    throw new Error("Could not parse deployedContracts.ts file");
  }

  // eslint-disable-next-line no-eval
  return eval("(" + match[1] + ")");
}

/**
 * Get contract data from deployed contracts
 * @param chainId - The chain ID
 * @param contractName - The contract name
 * @returns The contract data with address, txHash, and abi
 */
export function getContractData(chainId: string, contractName: string) {
  const deployedContracts = loadDeployedContracts();

  if (
    !deployedContracts ||
    !deployedContracts[chainId] ||
    !deployedContracts[chainId][contractName]
  ) {
    throw new Error(
      `Contract ${contractName} not found in deployedContracts for chain ${chainId}`,
    );
  }

  const contractData = deployedContracts[chainId][contractName];
  if (!contractData.abi) {
    throw new Error(
      `ABI not found for contract ${contractName} on chain ${chainId}`,
    );
  }

  return contractData;
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function contractHasInitializeFunction(contractData: any): boolean {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return contractData.abi.some((abi: any) => abi.name === "initialize");
}

